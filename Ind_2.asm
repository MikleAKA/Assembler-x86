ORG 100h

section .data
    ; Массив и максимальное нечетное число
	array dw 1300, 22, 3821, 53108, 5241, 601, 7054, 9311, 9654, 1003, 11, 1202, 13000, 1405, 15 ; max = 8035
    ; Шаблоны семисегментного индикатора для двоичных цифр (0 и 1)
    digits db 0x3F, 0x06  ; 0 и 1

section .text
global _start

__start:
	mov sp, 0x300		 ; Установка стека в 300
	call clear_display_and_memory	; Очистка дисплея и памяти перед отображением числа
	call delay_cycle	 ; Задержка
	call delay_cycle	 ; Задержка
    mov cx, 0xF          ; Количество элементов в массиве
    mov bx, array      	 ; Адрес начала массива
    mov ax, 0            ; Инициализация максимального числа

findMaxOdd:
	mov dx, [bx]    	 ; Запись элемента массива во временный регистр
    test dl, 1      	 ; Проверка на чётность/нечётность
    jz nextElement       ; Если чётное, переходим к следующему
    cmp dx, ax           ; Сравниваем с текущим максимумом
    jbe nextElement      ; Если меньше или равно, переходим к следующему
    mov ax, [bx]    	 ; Обновляем максимум

nextElement:
    add bx, 2            ; Переход к следующему элементу массива
    loop findMaxOdd      ; Повторяем пока не переберём все элементы
    mov [0200h], ax 	 ; Запись результата в память по адресу 0246h

displayBinary:			 ; Процедура для отображения числа в двоичном виде на индикаторах
	mov dx, 090h		 ; Установка dx в адрес крайнего правого индикатора
	mov ax, 0			 ; Установка аккумулятора в 0 для вывода пробела
	call cycle			 ; Вызов подпрограммы для обновления индикаторов
	call memory_set		 ; Вызов подпрограммы для обновления значений индикаторов в памяти
	call delay_cycle	 ; Задержка
	call delay_cycle	 ; Задержка
	mov ax, [0200h] ; Загрузка полученного числа из массива
	mov [0210h], ax ; Загрузка этого числа в новую ячейку для последующих операций с ним
	mov cx, 10h			 ; Установка количества элементов в массиве в cx
	
displayLoop:				; Отображение числа на семисегментных индикаторах
	mov ax, [0210h]	; Загрузка числа для анализа его байтов
	mov dx, 090h			; Установка dx в адрес крайнего правого индикатора
	and ax, 8000h			; Проверка первого бита на 1 или 0
	jz not_one				; Выбор шаблона отображения (0 или 1)
	mov ax, 1				; Если первый бит = 1, то ax = 0x1
	
not_one:
	mov si, ax				; Загрузка ax в si для выбора отображения индикатора
    mov al, [digits + si]	; Загрузка в ax значение индикатора
	push cx					; Загрузка счетчика cx в стек, чтобы не потерять в подпрограммах
	call cycle				; Вызов подпрограммы для обновления индикаторов
	call memory_set			; Вызов подпрограммы для обновления значений индикаторов в памяти
	call delay_cycle	 	; Задержка
	call delay_cycle	 	; Задержка
	pop cx					; Взятие сохраненного счетчика cx из стека
	mov ax, [0210h]	; Загрузка числа для анализа байтов
	shl ax, 1				; Сдвиг этого числа на 1 влево
	mov [0210h], ax	; Обновления числа
	loop displayLoop		; Пока cx не равен нулю, продолжаем анализ байтов

end:				; Бесконечный цикл для циклического отображения
    jmp displayBinary

clear_display_and_memory:	; Процедура очистки семисегментных индикаторов и соответствующей памяти
	mov cx, 7				; Установка счетчика в 7
	mov al, 0x3F 			; Загрузка в ax отображения 0
	mov dx, 090h			; Загрузка в dx адрес крайнего правого числа
	out dx, al				; Вывод на индикаторы 0 (очистка индикаторов)
	clear_display:			; Заполнение индикатора нулями (проходка по всем)
		add dx, 2			; Добавляем 2 к dx, чтобы пройтись по всем индикаторам
		out dx, al			; Вывод 0 на индикатор
		loop clear_display  ; Пока cx не равен 0 заполняем нулями

	mov bx, 24eh			; Установка bx в начальный адрес памяти хранения значений индикаторов
	mov word dx, 0x3F		; Установка dx в значение 0 на индикаторе
	mov cx, 8				; Установка счетчика cx в 8
	clear_memory:			; Очистка памяти для хранения индикаторов
		mov [bx], dx	; Заполняем память значениями 0 на индикаторе
		add bx, 2			; Добавляем 2, чтобы пройтись по всем ячейкам
		loop clear_memory	; Проходимся пока cx не равен 0
	ret
	
cycle:		; Процедура обновления отображения на семисегментных индикаторах
	out dx, ax		; Вывод на индикатор
	mov bx, 24eh
	mov [bx], ax
	mov cx, 7
	cycle_set:				; Обновление каждого индикатора
		add bx, 2
		add dx, 2
		mov ax, [bx]
		out dx, ax
		loop cycle_set
	ret
	
memory_set:		; Процедура обновления памяти для хранения текущего состояния индикаторов
	mov bx, 25ch
	mov cx, 7

	memory_set_cycle:	; Обновление значений в памяти для индикаторов
		mov ax, [bx-2]
		mov [bx], ax
		sub bx, 2
		loop memory_set_cycle
	ret

delay_cycle:	; Задежка
	mov cx, 0xFFFF
	delay:
		nop
		nop
		nop
		nop
		nop
		loop delay
	ret
